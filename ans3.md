# Answer 3

## A1

opcode 有 64 条，则需要 6bit 才能表示完整。
register 有 56 个，也需要 6bit 才能表示完整。
则 IMM 可⽤位数为： 32 - 6 - 6 - 6 = 14bit
则表示范围： $-2^{13}<IMM<2^{13}-1$

## A2

前 4 个都比较显然，第 5 个注意循环 `R0` 循环加 2 直到加到 x8000后循环中止，再加上后面的 3 和 1，得到 x8004.

|   **X**   | Does the program halt? | Value stored in `R0` |
| :-------: | :--------------------: | :------------------: |
| 000000010 |          Yes           |          2           |
| 000000001 |          Yes           |          3           |
| 000000000 |          Yes           |          6           |
| 111111111 |           No           |          --          |
| 111111110 |          Yes           | x8004 ($-2^{15}+4$)  |

## A3

当 `R1` 加 `R2` 的和为正数或 0 时，之后执行到 x3039.

## A4

1. ADD(0001) 和 AND(0101) 有了更⼤的⽴即数范围。但 NOT(1001) 没有获益。

2. LD(0010) 和 ST(0011) 能有更多的⼀位去寻址。

3. BR(0000) 中没有寄存器，因此没有获益。

## A5

101, 011, 010, 110, 110

内存单元内存储的值只需看最后一次写入时的输入 $D_{in}$，$D_{out}$ 看最后一次操作

> 若回答 `111, 011, 010, 111, 111`，则判此题完全不得分

## A6

此题需要严密的推理。

| Operation No. | R/W  | MAR   | MDR   |
| ------------- | ---- | ----- | ----- |
| 1             | W    | x4000 | 11110 |
| 2             | R    | x4003 | 10110 |
| 3             | W    | x4001 | 10110 |
| 4             | R    | x4002 | 01101 |
| 5             | W    | x4003 | 01101 |

<center>Operations on Memory</center>

| Address | Before Access 1 | After Access 3 | After Access 5 |
| ------- | --------------- | -------------- | -------------- |
| x4000   | 01101           | 11110          | 11110          |
| x4001   | 11010           | 10110          | 10110          |
| x4002   | 01101           | 01101          | 01101          |
| x4003   | 10110           | 10110          | 01101          |
| x4004   | 11110           | 11110          | 11110          |

<center>Contents of Memory locations</center>

## A7

a. $2\times10^8$

b. $2.5\times10^7$

c. $\approx2\times10^8$

## A8

```
1. 1001 111 001 111111 // (NOT 1) -> 7
2. 1001 110 010 111111 // (NOT 2) -> 6
3. 0101 101 111 000 010 // 7 AND 2 -> 5
4. 0101 100 110 000 001 // 6 AND 1 -> 4
5. 1001 001 101 111111 // (NOT 5) -> 1
6. 1001 010 100 111111 // (NOT 4) -> 2
7. 0101 000 001 000 010 // 1 AND 2 -> 0
8. 1001 011 000 111111 // (NOT 0) -> 3
```

## A9

其中第2条可以作为NOP，因为其偏移设置为0

1. 将R1中的值与立即数2相加并存放到R2中
2. NOP
3. 检查标志位N和P，若其中一个被置位则跳转到对应的位置
4. 对R7求反存放到R2中
5. TRAP指令，读取内存单元x0023中的内容作为服务程序入口

## A10
