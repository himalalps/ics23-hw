# Answer 1

## A1

## A2

## A3

1. `int`型的范围为$-2^{31}\sim2^{31}-1$，因此两个`int`型变量相减得到的结果范围也最多为$-2^{31}\sim2^{31}-1$，如果变量`a`比变量`b`大超过$2^{31}$，则`a - b`会溢出，结果为负数，此时会输出`a < b`.
2. `unsigned int`型取负数也是取反加一，不过结果会被作为`unsigned int` 看待，因此$-a$相当于$2^{32}-a$，不过有一个特殊的数`0`，其取负之后依然为`0`，因此如果`b = 0`，而`a`非零，就会输出`a < b`.

## A4

$10001011_B = 139_D$

因此为$$\begin{align}&(1.00000000001000000001000)\times2^{139-127}\nonumber\\=&1000000000010.00000001_B\nonumber\\=&4098.00390625_D\nonumber\end{align}$$

## A5

最小可以表示的浮点数为$-(2-2^{-23})\times2^{127}$，也就是
1 11111110 11111111111111111111111

最小可以表示的正数为$2^{-23}\times2^{-126}$，也就是0 00000000 00000000000000000000001

## A6

```c
#include <limits.h>
#include <stdio.h>
union my_union {
    int a;
    float b;
};
int main(void) {
    union my_union t;
    for (int i = INT_MIN; i < INT_MAX; i++) {
        t.b = i;
        if (t.a == i) {
            printf("%d\n", i);
        }
    }
    return 0;
}
```

运行程序，得到结果-834214802, 0, 1318926965.

## A7

1. 答案如下

```c
void swap(int *a, int *b) {
    *a = *a ^ *b;
    *b = *a ^ *b;
    *a = *a ^ *b;
}
```

2. 如果`swap`函数中的`a`和`b`指向相同的地址，则第一行异或后该地址就会变成`0`，第二行异或会使该地址变成`1`，第三行再异或就得到`0`，也就是如果`a == b`时，会使地址上的值变成`0`，而不再是原来数组里的值。要改正的话只需在`swap`中或是`sort`中对要交换的两个指针判断是否相等即可。

## A8

## A9

## A10
